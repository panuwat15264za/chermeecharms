<!doctype html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>Cheŕmee charm | ออกแบบสร้อย</title>
    <link rel="stylesheet" href="product.css" />
</head>

<body class="productPage">

    <nav class="topnav">
        <a class="brand" href="index.html">Cheŕmee charm</a>
        <div class="links">
            <a href="index.html">Lookbook</a>
            <a class="active" href="product.html">ออกแบบสร้อย</a>
        </div>
    </nav>

    <div class="productWrap">
        <div class="productTop">
            <div class="productTitle">
                <h1>ลองเรียงชาร์มเป็นสร้อย</h1>
                <p>ลากรูปด้านล่างขึ้นมาวางบนกระดาน • ลากชิ้นงานเพื่อขยับ • ดับเบิลคลิกลบ</p>
            </div>

            <div class="productActions">
                <button id="btnCenter" class="soft">จัดเรียงกลาง</button>
                <button id="btnClear" class="soft">ล้างทั้งหมด</button>
                <button id="btnSave">บันทึกรูป</button>
            </div>
        </div>

        <div id="board" class="board">
            <div class="boardHint">
                ลากชาร์มมาวางที่นี่ ✨
            </div>

            <div id="baseLayer" class="baseLayer"></div>

            <div class="neckline" aria-hidden="true"></div>
        </div>

        <div class="tray">
            <div class="trayHead">
                <div class="pill">เลือกชาร์มด้านล่างแล้วลากขึ้นไป</div>
            </div>

            <div id="trayList" class="trayList"></div>
        </div>

        <div class="baseBar">
            <div class="pill">เลือกตัวเรือนนาฬิกา</div>
            <div id="baseList" class="baseList"></div>
        </div>
    </div>

    <div id="transformUI" class="transformUI hidden">
        <button data-act="rotate">⟳</button>
        <button data-act="scaleDown">−</button>
        <button data-act="scaleUp">＋</button>
    </div>


    <script>
        (function () {
            const board = document.getElementById('board');
            const tray = document.getElementById('trayList');
            const baseLayer = document.getElementById('baseLayer');
            const baseList = document.getElementById('baseList');

            let BASES = [];
            let selectedBase = null;

            const isTouchLike = () => window.matchMedia('(pointer: coarse)').matches;

            let activeEl = null;
            const ui = document.getElementById('transformUI');

            function showTransformUI(el) {
                activeEl = el;
                const r = el.getBoundingClientRect();
                const br = board.getBoundingClientRect();

                ui.style.left = (r.left - br.left + r.width / 2 - 60) + 'px';
                ui.style.top = (r.top - br.top - 46) + 'px';
                ui.classList.remove('hidden');
            }

            function hideTransformUI() {
                activeEl = null;
                ui.classList.add('hidden');
            }

            ui.addEventListener('click', (e) => {
                if (!activeEl) return;
                const act = e.target.dataset.act;
                if (!act) return;

                activeEl._transform = activeEl._transform || { scale: 1, rotate: 0 };

                if (act === 'rotate') activeEl._transform.rotate += 15;
                if (act === 'scaleUp') activeEl._transform.scale = Math.min(activeEl._transform.scale + 0.1, 3);
                if (act === 'scaleDown') activeEl._transform.scale = Math.max(activeEl._transform.scale - 0.1, 0.4);

                activeEl.style.transform =
                    `rotate(${activeEl._transform.rotate}deg) scale(${activeEl._transform.scale})`;
            });


            function getBoardXY(clientX, clientY) {
                const rect = board.getBoundingClientRect();
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top,
                    rect
                };
            }

            let scrollYBeforeLock = 0;
            function lockScroll() {
                scrollYBeforeLock = window.scrollY || 0;
                document.documentElement.classList.add('lockScroll');
                document.body.classList.add('lockScroll');
                document.body.style.top = `-${scrollYBeforeLock}px`;
            }

            function unlockScroll() {
                document.documentElement.classList.remove('lockScroll');
                document.body.classList.remove('lockScroll');

                const top = document.body.style.top;
                document.body.style.top = '';
                const y = top ? -parseInt(top, 10) : scrollYBeforeLock;
                window.scrollTo(0, y);
            }

            async function loadBaseFromJson() {
                try {
                    const res = await fetch('bases.json', { cache: 'no-store' });
                    if (!res.ok) throw new Error('โหลด bases.json ไม่สำเร็จ: ' + res.status);

                    const data = await res.json();
                    const basePath = data.basePath || '';
                    const files = Array.isArray(data.files) ? data.files : [];

                    BASES = files.map((name, i) => ({
                        name: `Base ${i + 1}`,
                        src: basePath + name
                    }));

                    renderBaseList();
                } catch (err) {
                    console.error(err);
                    baseList.innerHTML = `<div style="color:rgba(255,255,255,.75);padding:6px 2px">
                  ไม่พบ bases.json หรือโหลดไม่ได้ — กรุณาเช็คว่า bases.json อยู่ข้างๆ product.html
                </div>`;
                    baseLayer.innerHTML = '';
                }
            }

            function renderBaseList() {
                baseList.innerHTML = "";
                BASES.forEach((b, idx) => {
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "baseItem";
                    btn.innerHTML = `<img src="${b.src}" alt="${b.name}">`;
                    btn.addEventListener("click", () => setBase(idx));
                    baseList.appendChild(btn);
                });
            }

            function setBase(index) {
                selectedBase = BASES[index];

                [...baseList.querySelectorAll(".baseItem")].forEach((el, i) => {
                    el.classList.toggle("active", i === index);
                });

                baseLayer.innerHTML = "";
                if (!selectedBase) return;

                const basePiece = document.createElement("div");
                basePiece.className = "basePiece";

                const br = board.getBoundingClientRect();
                basePiece.style.left = (br.width / 2 - 150) + "px";
                basePiece.style.top = (br.height / 2 - 80) + "px";

                const img = document.createElement("img");
                img.src = selectedBase.src;
                img.alt = selectedBase.name;
                img.draggable = false;

                basePiece.appendChild(img);
                baseLayer.appendChild(basePiece);

                enablePinchRotate(basePiece, board);
                basePiece.addEventListener('pointerdown', (e) => {
                    e.stopPropagation();
                    showTransformUI(basePiece);
                });

            }

            async function loadTrayFromJson() {
                try {
                    const res = await fetch('images.json', { cache: 'no-store' });
                    if (!res.ok) throw new Error('โหลด images.json ไม่สำเร็จ: ' + res.status);

                    const data = await res.json();
                    const base = data.basePath || '';
                    const files = Array.isArray(data.files) ? data.files : [];

                    tray.innerHTML = '';

                    files.forEach((name) => {
                        const img = document.createElement('img');
                        img.className = 'charm';
                        img.draggable = !isTouchLike();
                        img.loading = 'lazy';
                        img.src = base + name;
                        img.alt = name;
                        tray.appendChild(img);
                    });

                } catch (err) {
                    console.error(err);
                    tray.innerHTML = `<div style="color:rgba(255,255,255,.75);padding:10px">
                  ไม่พบ images.json หรือโหลดไม่ได้ — กรุณาเช็คว่า images.json อยู่ข้างๆ product.html
                </div>`;
                }
            }

            tray.addEventListener('dragstart', (e) => {
                const img = e.target.closest('img.charm');
                if (!img) return;

                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', img.src);
                e.dataTransfer.setData('text/uri-list', img.src);
            });

            board.addEventListener('dragover', (e) => {
                e.preventDefault();
                board.classList.add('dragOver');
                e.dataTransfer.dropEffect = 'copy';
            });

            board.addEventListener('dragleave', () => board.classList.remove('dragOver'));

            board.addEventListener('drop', (e) => {
                e.preventDefault();
                board.classList.remove('dragOver');

                const src = e.dataTransfer.getData('text/plain');
                if (!src) return;

                const { x, y } = getBoardXY(e.clientX, e.clientY);
                addCharmPiece(src, x, y);
            });

            board.addEventListener('pointerdown', () => {
                hideTransformUI();
            });

            let ghost = null;
            let draggingSrc = null;
            let dragging = false;

            function moveGhost(x, y) {
                if (!ghost) return;
                ghost.style.left = (x - 26) + 'px';
                ghost.style.top = (y - 26) + 'px';

                const br = board.getBoundingClientRect();
                const inside = x >= br.left && x <= br.right && y >= br.top && y <= br.bottom;
                board.classList.toggle('dragOver', inside);
            }

            function finishMobileDrop(clientX, clientY) {
                const br = board.getBoundingClientRect();
                const inside = clientX >= br.left && clientX <= br.right && clientY >= br.top && clientY <= br.bottom;

                if (inside && draggingSrc) {
                    const { x, y } = getBoardXY(clientX, clientY);
                    addCharmPiece(draggingSrc, x, y);
                }
                cleanupMobileDrag();
            }

            function cleanupMobileDrag() {
                dragging = false;
                draggingSrc = null;
                board.classList.remove('dragOver');
                if (ghost) ghost.remove();
                ghost = null;

                window.removeEventListener('pointermove', onMobileMove, { passive: false });
                window.removeEventListener('pointerup', onMobileUp, { passive: false });
                window.removeEventListener('pointercancel', onMobileCancel, { passive: false });

                unlockScroll();
            }

            function onMobileMove(e) {
                if (!dragging) return;
                e.preventDefault();
                moveGhost(e.clientX, e.clientY);
            }

            function onMobileUp(e) {
                if (!dragging) return;
                e.preventDefault();
                finishMobileDrop(e.clientX, e.clientY);
            }

            function onMobileCancel(e) {
                if (!dragging) return;
                e.preventDefault();
                cleanupMobileDrag();
            }

            tray.addEventListener('pointerdown', (e) => {
                const img = e.target.closest('img.charm');
                if (!img) return;
                if (!isTouchLike()) return;

                e.preventDefault();
                dragging = true;
                draggingSrc = img.src;

                lockScroll();

                ghost = document.createElement('img');
                ghost.src = draggingSrc;
                ghost.className = 'dragGhost';
                document.body.appendChild(ghost);

                moveGhost(e.clientX, e.clientY);

                window.addEventListener('pointermove', onMobileMove, { passive: false });
                window.addEventListener('pointerup', onMobileUp, { passive: false });
                window.addEventListener('pointercancel', onMobileCancel, { passive: false });
            }, { passive: false });

            function addCharmPiece(src, x, y) {
                const hint = board.querySelector('.boardHint');
                if (hint) hint.style.display = 'none';

                const piece = document.createElement('div');
                piece.className = 'piece';
                piece.style.left = (x - 28) + 'px';
                piece.style.top = (y - 28) + 'px';

                const img = document.createElement('img');
                img.src = src;
                img.alt = 'charm piece';
                img.draggable = false;

                piece.appendChild(img);
                baseLayer.appendChild(piece);

                enablePinchRotate(piece, board);

                piece.addEventListener('dblclick', () => removePiece(piece));
                addLongPressToRemove(piece);

                piece.addEventListener('pointerdown', (e) => {
                    e.stopPropagation();
                    showTransformUI(piece);
                });
            }

            function removePiece(piece) {
                piece.remove();
                if (!board.querySelector('.piece')) {
                    const hint2 = board.querySelector('.boardHint');
                    if (hint2) hint2.style.display = '';
                }
            }

            function addLongPressToRemove(el) {
                let t = null;
                el.addEventListener('pointerdown', () => {
                    if (!isTouchLike()) return;
                    t = setTimeout(() => {
                        el.remove();
                    }, 600);
                }, { passive: true });

                el.addEventListener('pointerup', () => { if (t) clearTimeout(t); t = null; }, { passive: true });
                el.addEventListener('pointercancel', () => { if (t) clearTimeout(t); t = null; }, { passive: true });
                el.addEventListener('pointermove', () => { if (t) clearTimeout(t); t = null; }, { passive: true });
            }

            function enableDragInsideBoard(piece, { isBase = false } = {}) {
                let dragging = false;
                let offsetX = 0, offsetY = 0;

                piece.addEventListener('pointerdown', (e) => {
                    e.preventDefault();

                    if (isTouchLike()) lockScroll();

                    dragging = true;
                    piece.setPointerCapture(e.pointerId);
                    piece.classList.add('active');

                    const pr = piece.getBoundingClientRect();
                    offsetX = e.clientX - pr.left;
                    offsetY = e.clientY - pr.top;

                    if (isBase) piece.style.zIndex = 5;
                }, { passive: false });

                piece.addEventListener('pointermove', (e) => {
                    if (!dragging) return;
                    e.preventDefault();

                    const br = board.getBoundingClientRect();
                    let nx = e.clientX - br.left - offsetX;
                    let ny = e.clientY - br.top - offsetY;

                    const w = piece.offsetWidth;
                    const h = piece.offsetHeight;

                    nx = Math.max(0, Math.min(nx, br.width - w));
                    ny = Math.max(0, Math.min(ny, br.height - h));

                    piece.style.left = nx + 'px';
                    piece.style.top = ny + 'px';
                    piece.style.transform = '';
                }, { passive: false });

                piece.addEventListener('pointerup', () => {
                    dragging = false;
                    piece.classList.remove('active');
                    if (isTouchLike()) unlockScroll();
                });

                piece.addEventListener('pointercancel', () => {
                    dragging = false;
                    piece.classList.remove('active');
                    if (isTouchLike()) unlockScroll();
                });
            }

            function enablePinchRotate(el, container) {
                container = container || board;

                // state
                el._transform = el._transform || { scale: 1, rotate: 0 };
                let drag1 = false;
                let offsetX = 0, offsetY = 0;

                let pinching = false;
                let startDist = 0;
                let startAngle = 0;
                let startScale = 1;
                let startRotate = 0;

                const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

                function applyTransform() {
                    el.style.transform = `rotate(${el._transform.rotate}deg) scale(${el._transform.scale})`;
                }

                function getLocalXY(clientX, clientY) {
                    const cr = container.getBoundingClientRect();
                    return { x: clientX - cr.left, y: clientY - cr.top, cr };
                }

                // ====== 1 นิ้วลาก (pointer) ======
                el.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    el.setPointerCapture(e.pointerId);

                    // ถ้ากำลัง pinch อยู่ อย่าให้ลากแทรก
                    if (pinching) return;

                    drag1 = true;
                    const r = el.getBoundingClientRect();
                    offsetX = e.clientX - r.left;
                    offsetY = e.clientY - r.top;
                }, { passive: false });

                el.addEventListener('pointermove', (e) => {
                    if (!drag1 || pinching) return;
                    e.preventDefault();

                    const { x, y, cr } = getLocalXY(e.clientX, e.clientY);
                    let nx = x - offsetX;
                    let ny = y - offsetY;

                    const w = el.offsetWidth;
                    const h = el.offsetHeight;
                    nx = clamp(nx, 0, cr.width - w);
                    ny = clamp(ny, 0, cr.height - h);

                    el.style.left = nx + "px";
                    el.style.top = ny + "px";
                }, { passive: false });

                el.addEventListener('pointerup', () => { drag1 = false; }, { passive: true });
                el.addEventListener('pointercancel', () => { drag1 = false; }, { passive: true });

                // ====== 2 นิ้ว pinch/rotate (touch) ======
                // ใช้ touch events เพื่อให้ iOS/มือถือทำงานชัวร์
                el.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        pinching = true;
                        drag1 = false;

                        const t1 = e.touches[0];
                        const t2 = e.touches[1];

                        startDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                        startAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
                        startScale = el._transform.scale;
                        startRotate = el._transform.rotate;
                    }
                }, { passive: false });

                el.addEventListener('touchmove', (e) => {
                    if (!pinching || e.touches.length !== 2) return;
                    e.preventDefault();

                    const t1 = e.touches[0];
                    const t2 = e.touches[1];

                    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);

                    let scale = startScale * (dist / (startDist || dist));
                    scale = clamp(scale, 0.4, 3);

                    const rotate = startRotate + (angle - startAngle) * (180 / Math.PI);

                    el._transform.scale = scale;
                    el._transform.rotate = rotate;
                    applyTransform();
                }, { passive: false });

                function endTouch(e) {
                    if (e.touches.length < 2) pinching = false;
                }
                el.addEventListener('touchend', endTouch, { passive: true });
                el.addEventListener('touchcancel', () => { pinching = false; }, { passive: true });

                applyTransform();
            }

            document.getElementById('btnClear').addEventListener('click', () => {
                board.querySelectorAll('.piece').forEach(n => n.remove());
                baseLayer.innerHTML = '';
                [...baseList.querySelectorAll(".baseItem")].forEach(el => el.classList.remove("active"));
                const hint = board.querySelector('.boardHint');
                if (hint) hint.style.display = '';
            });

            document.getElementById('btnCenter').addEventListener('click', () => {
                const pieces = Array.from(board.querySelectorAll('.piece'));
                if (!pieces.length) return;

                const br = board.getBoundingClientRect();
                const midY = br.height * 0.52;
                const gap = 10;

                const totalW = pieces.reduce((sum, p) => sum + p.offsetWidth, 0) + gap * (pieces.length - 1);
                let startX = (br.width - totalW) / 2;
                startX = Math.max(10, startX);

                pieces.forEach((p) => {
                    p.style.left = startX + 'px';
                    p.style.top = (midY - p.offsetHeight / 2) + 'px';
                    startX += p.offsetWidth + gap;
                });
            });

            document.getElementById('btnSave').addEventListener('click', exportBaseLayerPNG);

            async function exportBaseLayerPNG() {
                // export เฉพาะของใน baseLayer (รวม basePiece + ชาร์มที่ถูกย้ายมาอยู่ใน baseLayer)
                const items = [...baseLayer.querySelectorAll('.basePiece, .piece')];

                // ให้เซฟได้เสมอ → ถ้าไม่มีอะไรเลย เซฟเป็น PNG โปร่งใสขนาดเท่าบอร์ด
                const boardRect = board.getBoundingClientRect();
                const w = Math.round(boardRect.width);
                const h = Math.round(boardRect.height);

                const dpr = window.devicePixelRatio || 1;
                const canvas = document.createElement('canvas');
                canvas.width = w * dpr;
                canvas.height = h * dpr;

                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);

                if (items.length) {
                    // รอโหลดรูปให้ครบก่อนวาด
                    const imgs = items.map(el => el.querySelector('img')).filter(Boolean);
                    await Promise.all(imgs.map(ensureImageLoaded));

                    // วาดตามลำดับ z-index (ถ้ามี) เพื่อให้ซ้อนถูก
                    items.sort((a, b) => {
                        const za = parseInt(a.style.zIndex || '0', 10);
                        const zb = parseInt(b.style.zIndex || '0', 10);
                        return za - zb;
                    });

                    for (const el of items) {
                        const img = el.querySelector('img');
                        if (!img) continue;

                        const x = parseFloat(el.style.left || '0');
                        const y = parseFloat(el.style.top || '0');

                        // ใช้ขนาด element จริง (เช่น piece 56x56 / base ตามที่มันแสดง)
                        const r = el.getBoundingClientRect();
                        const drawW = r.width;
                        const drawH = r.height;

                        ctx.save();
                        ctx.translate(x + drawW / 2, y + drawH / 2);
                        const t = el._transform || { scale: 1, rotate: 0 };
                        ctx.rotate(t.rotate * Math.PI / 180);
                        ctx.scale(t.scale, t.scale);
                        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                        ctx.restore();
                    }
                }

                canvas.toBlob((blob) => {
                    if (!blob) return;
                    downloadBlob(blob, `baseLayer-${Date.now()}.png`);
                }, 'image/png');
            }


            function ensureImageLoaded(img) {
                if (img.complete && img.naturalWidth) return Promise.resolve();
                return new Promise(res => {
                    img.addEventListener('load', res, { once: true });
                    img.addEventListener('error', res, { once: true });
                });
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }


            // init
            loadTrayFromJson();
            loadBaseFromJson();
        })();
    </script>
</body>

</html>